# Ghidra Headless Analysis Script - Critical Binaries
# Auto-generated by analyze_critical_binaries.ps1

from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
from java.io import File, FileWriter

def main():
    monitor = ConsoleTaskMonitor()
    program = getCurrentProgram()
    
    # Get program info
    program_name = program.getName()
    output_dir = "F:/repo/zerosms/analysis/critical_binaries_analysis/decompiled"
    report_dir = "F:/repo/zerosms/analysis/critical_binaries_analysis/reports"
    
    # Initialize decompiler
    ifc = DecompInterface()
    ifc.openProgram(program)
    
    # Analysis
    print("[*] Analyzing: " + program_name)
    
    # Get function listing
    function_manager = program.getFunctionManager()
    functions = function_manager.getFunctions(True)
    
    function_list = []
    interesting_functions = []
    
    # Keywords for unlock-related functions
    unlock_keywords = ["unlock", "carrier", "perso", "nv", "qmi", "modem", "verify", "check", "auth"]
    
    for func in functions:
        func_name = func.getName()
        func_addr = func.getEntryPoint().toString()
        function_list.append({'name': func_name, 'address': func_addr})
        
        # Check for interesting functions
        func_name_lower = func_name.lower()
        if any(keyword in func_name_lower for keyword in unlock_keywords):
            interesting_functions.append({'name': func_name, 'address': func_addr})
    
    print("[+] Total functions: " + str(len(function_list)))
    print("[+] Interesting functions: " + str(len(interesting_functions)))
    
    # Write function report
    report_file = File(report_dir, program_name + "_functions.txt")
    writer = FileWriter(report_file)
    writer.write("=" * 80 + "\n")
    writer.write("FUNCTION ANALYSIS: " + program_name + "\n")
    writer.write("=" * 80 + "\n\n")
    writer.write("Total functions: " + str(len(function_list)) + "\n")
    writer.write("Interesting functions: " + str(len(interesting_functions)) + "\n\n")
    
    writer.write("=" * 80 + "\n")
    writer.write("INTERESTING FUNCTIONS (Unlock-related)\n")
    writer.write("=" * 80 + "\n")
    for func in interesting_functions:
        writer.write(func['address'] + " | " + func['name'] + "\n")
    
    writer.write("\n" + "=" * 80 + "\n")
    writer.write("ALL FUNCTIONS\n")
    writer.write("=" * 80 + "\n")
    for func in function_list[:100]:  # First 100 functions
        writer.write(func['address'] + " | " + func['name'] + "\n")
    
    writer.close()
    print("[+] Report written: " + report_file.getPath())
    
    # Decompile interesting functions
    if len(interesting_functions) > 0:
        decompile_file = File(output_dir, program_name + "_decompiled.c")
        dec_writer = FileWriter(decompile_file)
        
        for func_info in interesting_functions[:20]:  # First 20 interesting functions
            try:
                func = function_manager.getFunctionAt(program.getAddressFactory().getAddress(func_info['address']))
                if func:
                    results = ifc.decompileFunction(func, 30, monitor)
                    if results and results.decompileCompleted():
                        dec_writer.write("// " + "=" * 70 + "\n")
                        dec_writer.write("// Function: " + func_info['name'] + "\n")
                        dec_writer.write("// Address: " + func_info['address'] + "\n")
                        dec_writer.write("// " + "=" * 70 + "\n")
                        dec_writer.write(results.getDecompiledFunction().getC())
                        dec_writer.write("\n\n")
            except Exception as e:
                print("[!] Failed to decompile: " + func_info['name'])
        
        dec_writer.close()
        print("[+] Decompilation written: " + decompile_file.getPath())

if __name__ == '__main__':
    main()
